import { Timestamp } from "../model/Timestamp";
import { Uuid } from "../model/Uuid";
import { Signal } from "../protos/api/signaling/v1/signaling_pb";
import { IRtcConnectionConfiguration } from "./models/IRtcConnectionConfiguration";
import { IRtcConnectionStatsInfo } from "./models/IRtcConnectionStatsInfo";
import { IRtcSendConfiguration } from "./models/IRtcSendConfiguration";
import { IRtcSessionMetricsMessageCounts } from "./models/IRtcSessionMetricsMessageCounts";
import { IRtcStreamMessage } from "./models/IRtcStreamMessage";
import { IStreamControl } from "./models/IStreamControl";
export declare class RtcConnection {
    peerConnection: RTCPeerConnection;
    private config;
    private dataChannelNotifier;
    private readonly connectTimeoutMs;
    private readonly iceGatheringTimeoutMs;
    private readonly pingUpdateTimeoutMs;
    private readonly streamsInfoUpdateTimeoutMs;
    private readonly reassemblyTimeoutMs;
    private readonly reassemblyTableCleanupMs;
    private readonly heartbeatTimeoutMs;
    private heartbeatChannel?;
    private latestTtlStreamChannel?;
    private reliableStreamChannel?;
    private latestReliableStreamChannel?;
    private latestTryOnceStreamChannel?;
    private streamLatestTimestamp;
    private reassemblyTable;
    private reassemblyTableLastTimestamp;
    private reassemblyTableCleanupTimeout;
    private pingUpdateTimeout;
    private streamsInfoUpdateTimeout;
    private heartbeatTimeout;
    private pingTimeMs;
    private lastMessageTimestamp;
    private sessionMetrics;
    private closeCalled;
    private gotOffer;
    private hasIceCandidate;
    constructor(peerConnection: RTCPeerConnection, config: IRtcConnectionConfiguration, dataChannelNotifier: (channel: RTCDataChannel) => void);
    handleSignal(signal: Signal): Promise<Signal | undefined>;
    /**
     * Sends a message to the remote peer.
     */
    send(message: IRtcStreamMessage, config: IRtcSendConfiguration): void;
    controlRemoteStream(streamControl: IStreamControl): void;
    isActive(): boolean;
    /**
     * Checks that the peerConnection is connected
     * and all data channels exist and are open
     */
    isReady(): boolean;
    close(): Promise<void>;
    getPing(): number | undefined;
    getLastMessageTimestamp(): Timestamp | undefined;
    getSessionCreatedTimestamp(): Timestamp | undefined;
    setSessionCreatedTimestamp(sessionCreatedTimestamp: Timestamp): void;
    getSessionId(): Uuid | undefined;
    setSessionId(sessionId: Uuid): void;
    getRemotePeerId(): Uuid | undefined;
    getRemoteDeviceId(): Uuid | undefined;
    setRemoteDeviceId(deviceId: Uuid | undefined): void;
    getSessionMetricsMessageCounts(): IRtcSessionMetricsMessageCounts | undefined;
    getConnectionStatsInfo(): Promise<IRtcConnectionStatsInfo | undefined>;
    private initializeChannels;
    getOffer(): Promise<Signal | undefined>;
    getLanOffer(): Promise<RTCSessionDescription | undefined>;
    handleLanAnswer(answerSdp: RTCSessionDescription): Promise<void>;
    private getChannelFromLabel;
    private sendOnChannel;
    private channelNotRecognized;
    private setupChannel;
    private receiveChannelMessage;
    private receiveChannelMessageChunk;
    /**
     * Handles system messages (e.g., ping/pong).
     * Returns true if the message is a system message.
     */
    private handleSystemMessage;
    private sendSystemMessage;
    private isLatestMessage;
}
